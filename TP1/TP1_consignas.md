# TP1 consignas

## Ejercicios
* [Ejercicio 1](#ejercicio-1)
* [Ejercicio 2](#ejercicio-2)
* [Ejercicio 3](#ejercicio-3)
* [Ejercicio 4](#ejercicio-4)
* [Ejercicio 5](#ejercicio-5)
* [Ejercicio 6](#ejercicio-6)
* [Ejercicio 7](#ejercicio-7)
* [Ejercicio 8](#ejercicio-8)
* [Ejercicio 9](#ejercicio-9)
* [Ejercicio 10](#ejercicio-10)
* [Ejercicio 11](#ejercicio-11)
* [Ejercicio 12](#ejercicio-12)
* [Ejercicio 13](#ejercicio-13)

## Ejercicio 1

Implemente los mÃ©todos indicados del esqueleto de Lista desarrollado en TeorÃ­a 
  - insertFront
  - extractFront
  - isEmpty
  - size
  - toString
  - Agregar tambiÃ©n el mÃ©todo: T get(index).

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 2
Considerando la implementaciÃ³n de la Lista realizado en el ejercicio anterior, comparar la complejidad computacional contra un array en las siguientes operaciones:
  - Insertar al principio.
  - Buscar un elemento en una posiciÃ³n.
  - Determinar la cantidad de elementos.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 3
Implemente una Pila utilizando la Lista del ejercicio 1. 

Metodos de una pila: 
  - A una pila se le pueden agregar elementos utilizando el mÃ©todo push(T o). 
  - Para retirar elementos de la colecciÃ³n se utiliza el mÃ©todo pop(), que retorna el Ãºltimo elemento agregado a la colecciÃ³n y lo elimina de la misma. 
  - Es posible consultar el tope de la pila (sin eliminarlo) utilizando el mÃ©todo top().
  - Es posible invertir el orden de los elementos de la pila mediante el mÃ©todo reverse().

## Ejercicio 4
A la implementaciÃ³n de la clase Lista realizada en el ejercicio 1:

Agregue un mÃ©todo indexOf, que reciba un elemento y retorne el Ã­ndice donde estÃ¡ almacenado ese elemento, o
-1 si el elemento no existe en la lista.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 5
A partir de la clase Lista implementada en el ejercicio 1:

Implemente el patrÃ³n iterator-iterable, para que la lista sea iterable. Â¿Existe alguna ventaja computacional a la
hora de recorrer la lista de principio a fin si se cuenta con un iterador?

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 6
Escriba un procedimiento que dadas dos listas construya otra con los elementos comunes,
suponiendo que: 
  - A: Las listas estÃ¡n desordenadas y la lista resultante debe quedar ordenada. 
  - B: Las listas estÃ¡n ordenadas y la lista resultante debe mantenerse ordenada.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 7
Escriba una funciÃ³n que dadas dos listas construya otra con los elementos que estÃ¡n en la
primera pero no en la segunda.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 8
Considerando la implementaciÃ³n de Lista del ejercicio 1:

Realice una Lista doblemente vinculada.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 9
Implemente un algoritmo recursivo que verifique si una cadena de texto es palindroma
(capicua).

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 10
Implemente un algoritmo recursivo que determine si un arreglo de tamaÃ±o N estÃ¡ ordenado.
  - Â¿QuÃ© complejidad O tiene? (La complejidad en el peor caso)
  - Â¿Trae algÃºn problema hacerlo recursivo? Â¿CuÃ¡l?
  - Â¿QuÃ© cambiarÃ­a si la estructura fuera una lista en lugar de un arreglo?

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 11
Implemente un algoritmo recursivo para buscar un elemento en un arreglo ordenado
ascendentemente.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 12
Implemente un algoritmo recursivo que convierta un nÃºmero en notaciÃ³n decimal a su
equivalente en notaciÃ³n binaria.

[ğŸ”¼ volver al inicio](#ejercicios)

## Ejercicio 13

Implemente un algoritmo recursivo que presente los primeros N tÃ©rminos de la secuencia de
Fibonacci.

Por ej. los 6 primeros tÃ©rminos son: 0 1 1 2 3 5

[ğŸ”¼ volver al inicio](#ejercicios)